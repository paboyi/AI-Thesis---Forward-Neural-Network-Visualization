FILE: activation-function.ts -->

export enum EActivationFunction {
  SIGMOID
}

export class ActivationFunction {
  public static sigmoid(value: number): number {
    return 1 / (1 + Math.exp(-value));
  }




  public static activate(
    activationFunction: EActivationFunction,
    value: number
  ): number {
    switch (activationFunction) {
      case EActivationFunction.SIGMOID:
        return ActivationFunction.sigmoid(value);
    }
  }
}


----------------------------------------------------------------------------------


FILE: neurons.ts --->

import {
  ActivationFunction,
  EActivationFunction
} from './activation-functions';

interface INeuronOptions {
  activationFunction: EActivationFunction;
  previousLayerNeuronAmount: number;
}

export default class Neuron {
  private options: INeuronOptions;
  private weights: number[] = [];

  private initializeWeights(neuronAmount: number) {
    this.weights = [];
    for (let i = 0; i < neuronAmount; i++) {
      this.weights.push(Math.random());
    }
  }

  private transmissionFunction(inputs: number[]): number {
    let result = 0;
    for (let i = 0; i < inputs.length; i++) {
      result += inputs[i] * this.weights[i];
    }

    // x1 * w1 + x2 * w2 + ... + xn * wn
    return result;
  }

  constructor(options: INeuronOptions) {
    this.options = options;
    this.initializeWeights(options.previousLayerNeuronAmount);
  }

  public send(inputs: number[]): number {
    if (inputs.length !== this.weights.length) {
      throw new Error('Input length does not match weight length.');
    }

    const activationValue = this.transmissionFunction(inputs);
    return ActivationFunction.activate(
      this.options.activationFunction,
      activationValue
    );
  }
}


----------------------------------------------------------------------------------


FILE: neuronal-net.ts --->


import { EActivationFunction } from './activation-functions';
import Neuron from './neuron';

import path from 'path';
import Express from 'express';
import bodyParser from 'body-parser';


const app = Express();
app.use(bodyParser.json());




interface INeuronalNetOptions {
  activationFunction: EActivationFunction;
  inputCount: number;
  outputCount: number;
  hiddenLayers: number[]; // It's an Array. Of the amiunt of neuron per hidden layer
}


export default class NeuronalNet {
  private layers: Neuron[][];




  private initializeLayers(options: INeuronalNetOptions) {
    let layers: Neuron[][] = [];

    for (
      let layerIndex = 0;
      layerIndex < options.hiddenLayers.length + 1; // go through Hidden layers + output layer
      layerIndex++
    ) {
      const neuronAmount: number =
        layerIndex < options.hiddenLayers.length
          ? options.hiddenLayers[layerIndex] // Neuron amount of the current hidden layer
          : options.outputCount; // Neuron amount of the output layer

      let layer: Neuron[] = [];

      for (let neuronIndex = 0; neuronIndex < neuronAmount; neuronIndex++) {
        layer.push(
          new Neuron({
            activationFunction: options.activationFunction,
            previousLayerNeuronAmount:
              layerIndex === 0
                ? options.inputCount
                : layers[layerIndex - 1].length
          })
        );
      }

      layers.push(layer);
    }

    return layers;
  }





  constructor(options: INeuronalNetOptions) {
    this.layers = this.initializeLayers(options);
  }




  public send(inputs: number[]) {
    let outputs: number[] = inputs;
    for (let layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {
      let layerOutputs: number[] = [];
      for (
        let neuronIndex = 0;
        neuronIndex < this.layers[layerIndex].length;
        neuronIndex++
      ) {
        const neuron = this.layers[layerIndex][neuronIndex];
        layerOutputs.push(neuron.send(outputs));
      }
      outputs = layerOutputs;
    }

    console.log("Output from neural-nets.ts: \n", outputs);

    return outputs; // Just return the data for index.ts to use

  }

}





----------------------------------------------------------------------------------


FILE: index.ts --->



import path from 'path';
import Express from 'express';
import bodyParser from 'body-parser';

import { EActivationFunction } from './lib/neuronal-net/activation-functions';
import NeuronalNet from './lib/neuronal-net/neuronal-net';

const app = Express();
app.use(bodyParser.json()); // to parse JSON from requests

const nn = new NeuronalNet({
  activationFunction: EActivationFunction.SIGMOID,
  inputCount: 3,
  outputCount: 2,
  hiddenLayers: [4]
});


// Serve static files (e.g., index.html, styles.css)
app.use(Express.static(path.join(__dirname)));


// Serve HTML page
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'index.html'));
});


// This receives input data from the browser
app.post('/send-input', (req, res) => {
  const input = req.body.input;
  console.log('Received input from client:', input);

  try {
    const output = nn.send(input); // Process input through the network
    res.json({ output }); // Send result back to frontend
    
  } catch (error) {
    console.error(error);
    res.status(400).json({ error: 'Neural network error' });
  }
});


// Start the Sercer
app.listen(3000, () => {
  console.log('Server is running on port 3000');
});




----------------------------------------------------------------------------------


FILE: index.html --->

<!DOCTYPE html>
<html>
  <head>
    <title>Test</title>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>


    <div class="canvas-wrapper">
      <canvas id="canvas"></canvas>
    </div>



    <form id="inputForm">
      <label for="input">Enter input (comma-separated):</label> <br>
      <input type="text" id="input" placeholder="Enter 3 numbers (e.g. 1, 0, 2)">
      <button type="submit">Send</button>
    </form>
  
    <div id="result"></div>


    <script src="index.js"></script>

  </body>
</html>




----------------------------------------------------------------------------------


FILE: index.js --->


const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const size = 40; // size of square (w & h)
const xSpacing = 200;
const ySpacing = 100;


const inputCount = 3;
const hiddenLayers = [3, 4, 1, 3];
const outputCount = 2;



    // FUNCTION 1
function renderNetwork(inputCount, hiddenLayers, outputCount){
  totalLayers = 1 + hiddenLayers.length + 1; 
  console.log('totalLayers', totalLayers); // Total layers in the neural network. (Input, hidden + output layers count)

  nV = [inputCount, hiddenLayers, outputCount].flat(); //nV - neuronValues // flattens the 2d array to 1d [1,[2,3],4] = [1,2,3,4]
  console.log('nV.flat() = ', nV);
  return nV; //returns flat array [1,2,3,4]
  
}

renderNetwork(inputCount, hiddenLayers, outputCount); // the canvas will display columns with e.g. [1,2,3,4] neurons]




    // FUNCTION 2
function calculateCanvasSize(inputCount, hiddenLayers, outputCount) {
    const totalLayers = 2 + hiddenLayers.length;
    const maxNeurons = Math.max(inputCount, ...hiddenLayers, outputCount); // returns the number with the highest value

   console.log("Math.Max() = ",maxNeurons);
   console.log("... hiddenLayers = ",...hiddenLayers);

    const width = totalLayers * xSpacing + size;
    const height = maxNeurons * ySpacing + size;
  
    return { width, height };
  }
  

  const { width, height } = calculateCanvasSize(inputCount, hiddenLayers, outputCount);
  canvas.width = width;
  canvas.height = height;






    // FOR Loop 1
    let neurons = [];
    let xDistance = 100;
    let allObjects = []; //to gather each neuron in a 1d array

for (i=0; i<nV.length; i++) // loop through flattened array
{
  let yDistance = 50;
  let eachObjects = []; // to gather each neuron according to layer

  console.log('nV[i] = ', nV[i]); //which layer are we in?

    for (p=0; p<nV[i]; p++) //loop through each layer
    {
      let obj1 = {x: xDistance, y: yDistance, active: false}; // obj is a neuron. Rememebr these properties, x,y & false. We'll use them again
      eachObjects.push(obj1); 
      allObjects.push(obj1);

      yDistance += ySpacing; // or +100 if ySpacing doesn't work
      console.log('inner obj = ', obj1);
    }

    neurons.push(eachObjects); //eachObjects [] is an array
    xDistance += xSpacing; // or +200 if ySpacing doesn't work
}
console.log('allObjects = ', allObjects);
console.log('neurons = ', neurons);







const lines = [];
for (i = 0; i < allObjects.length; i++) {
 let l = {from: i, to: i+1};
 lines.push(l);
}
console.log('lines = ',lines); //didn't end up using this


ctx.strokeStyle = 'red'; // #acff30
ctx.lineWidth = 2;

 
for (i=0; i<neurons.length-1; i++) {

 for (j=0; j<neurons[i].length; j++) { // Stop drawing lines at second-to-the-last layer

   const start = neurons[i][j]; // Neuron in the current layer
   const x1 = start.x + (size / 2);  //start.x. x is a property of obj1 (a single neuron). See above
   const y1 = start.y + (size / 2); // this ensures the lines start from the middle of each neuron

   for (let k = 0; k < neurons[i + 1].length; k++) { // Loop through next layer
   const end = neurons[i+1][k]; // Neuron in the next layer
   const x2 = end.x + (size / 2);
   const y2 = end.y + (size / 2);
   
   console.log(`Connecting (x1:${x1}, y1:${y1}) to (x2:${x2}, y2:${y2})`);

   ctx.moveTo(x1, y1);
   ctx.lineTo(x2, y2);
   ctx.stroke(); 
   }
 
  }
}




    // FUNCTION 3
 function drawNeurons(neurons) {

 for (i=0; i<neurons.length; i++) {
   for (let neuron of neurons[i]) {
    ctx.fillStyle = neuron.active ? 'red' : '#acff30';
    ctx.fillRect(neuron.x, neuron.y, size, size); //create squares (neurons)
   }
 } 
}
drawNeurons(neurons);





    // Handle user input

const form = document.getElementById('inputForm');
const resultDiv = document.getElementById('result');

  form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const inputStr = document.getElementById('input').value;
  const inputArray = inputStr.split(',').map(Number); // turn "1,0,2" into [1,0,2]


      if (inputArray.length !== 3) {
    resultDiv.innerText = 'Please enter exactly 3 numbers!';
    return;
    }


      const response = await fetch('/send-input', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ input: inputArray })
  })
  // .then(res => res.json())
  // .then(data => {
  //   const activatedIndexes = data.output;
  //   activateNeurons(activatedIndexes); // <-- call visual update
  // });



  const data = await response.json();
  console.log('Received from server:', data);

  // Handle response clearly
    if (Array.isArray(data.output) && data.output.length > 0) {
    resultDiv.innerText = 'Output: ' + data.output.join(', ');
    } else if (data.error) {
    resultDiv.innerText = 'Error: ' + data.error;
    } else {
    resultDiv.innerText = 'No output or unexpected result.';
    }
  }
);

----------------------------------------------------------------------------------
